<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 13. Interactive Viewing of 3D Objects</title><meta name="generator" content="DocBook XSL Stylesheets V1.51.1"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.1"><link rel="home" href="index.html" title="IRIX® Interactive Desktop
User Interface Guidelines"><link rel="up" href="pt03.html" title="Part III. 3D Style Guidelines"><link rel="previous" href="ch12.html" title="Chapter 12. Introduction to 3D Style Guidelines"><link rel="next" href="ch14.html" title="Chapter 14. Selection in 3D Applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 13. Interactive Viewing of 3D Objects</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch12.html">Prev</a> </td><th width="60%" align="center">Part III. 3D Style Guidelines</th><td width="20%" align="right"> <a accesskey="n" href="ch14.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><a name="sgi_start_content"></a><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="id5498951"></a>Chapter 13. <a name="id49713"></a>Interactive Viewing of 3D Objects</h2></div></div>
<p>Interactive viewing must be supported in the user interface of all 3D applications, even if those applications don't support editing. </p>
<p>Viewing 3D content is more complex than viewing a 2D image because of the added dimension. This added dimension means not only that there is more to look at, but also that there are more ways of looking at things. For example, users may want to view the sides, back, and top of a 3D model of a computer, walk through a virtual room, or fly through a 3D landscape. Interface designers have to determine the appropriate viewing functionality for their application and implement it in a consistent and intuitive way. </p>
<p>This chapter discusses interactive viewing of 3D objects in these sections: </p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch13.html#id15212">&#8220;Introduction to 3D Viewing&#8221;</a> provides an introduction to the viewing paradigm and discusses some terminology.</p>
</li>
<li><p><a href="ch13.html#id58437">&#8220;3D Viewing Functions&#8221;</a> introduces inspection and navigation, which are two different viewing modes, and describes the viewing functions an application needs to support in each mode. </p>
</li>
<li><p><a href="ch13.html#id94814">&#8220;3D Viewing Interface Trade-Offs&#8221;</a> discusses 3D application design issues that developers typically must address and provides recommendations for resolving these issues. </p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5499091"></a><a name="id15212"></a>Introduction to 3D Viewing</h2></div></div>
<p>3D viewing can be thought of as using a camera to view the world. The following concepts are used in this document to describe the user interface to viewing functions (see <a href="ch13.html#id26229">Figure 13-1</a>): </p>
<div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>Eyepoint</b></span>. The eyepoint is the position of the user's eye. The camera is always positioned at the eyepoint. As the user moves the location of the camera, the location of the eyepoint also changes.</p>
</li>
<li><p>Viewing area. The viewing area is what the user can currently see while looking through the camera. It's what the user sees in the application's viewport.</p>
</li>
<li><p><span class="bold"><b>Viewing direction</b></span>. The viewing direction refers to how the camera is oriented in space. As the user turns the camera to the left or right or tilts the camera up or down, the viewing direction changes accordingly. As the user changes the viewing direction, the contents of the viewing area also changes. In effect, the user is looking through the camera at a different part of the scene.</p>
</li>
<li><p><span class="bold"><b>Look-at point</b></span>. The look-at point is the current center of interest within the scene. The camera's viewing direction is always aimed so that the look-at point is in the center of the viewing area.</p>
<p><div class="figure"><p><a name="id5499196"></a><b>Figure 13-1. <a name="id26229"></a>The Camera Analogy in 3D Viewing</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/view_intro.gif" alt="Figure 13-1 The Camera Analogy in 3D Viewing" height="296" width="488"></td></tr></table></div></div><br>
</p>
</li>
</ul></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5499224"></a><a name="id58437"></a>3D Viewing Functions</h2></div></div>
<p>In the context of this document, <i>viewing<a name="idch13.3Dview1"></a></i> refers to manipulating a camera to view the contents of a 3D application (see <a href="ch13.html#id15212">&#8220;Introduction to 3D Viewing&#8221;</a>). This document distinguishes between the two basic viewing modes, inspection and navigation. Every 3D application needs to support at least one; if your application supports both, pick one as the primary mode.</p>
<p>Although viewing refers to manipulating a camera in a 3D application, users may base their interaction with the application on a different metaphor. These fundamental metaphors are also discussed in the following sections. For example, during inspection users interact with the scene (or object) they are viewing as if it were a single object that they are holding in their hand. They expect to be able to move this scene (or object) around in space (see <a href="ch13.html#id93079">&#8220;3D Viewing Trade-Offs and Related Guidelines&#8221;</a>). Application developers, on the other hand, find it useful to implement the inspection functions in terms of a camera that moves around the scene being viewed. It's important that your application allows users to work with viewing functions using the metaphors they expect regardless of how the application implements them.</p>
<p>This section describes the different functions available in inspection and in navigation. <a href="ch13.html#id83685">Table 13-1</a> provides an overview of each function, the mouse and key bindings used to access it, and the pointer shape displayed when the user is accessing it. Each function is discussed in detail in the following sections.</p>
<div class="table"><p><a name="id5499368"></a><b>Table 13-1. <a name="id83685"></a> 3D Viewing Functions and User Interface</b></p>
<table summary=" 3D Viewing Functions and User Interface" border="1"><colgroup><col><col><col><col></colgroup><thead><tr valign="top"><th scope="col" valign="top"><p>Function</p>
</th><th scope="col" valign="top"><p>View Mode</p>
</th><th scope="col" valign="top"><p>Pointer</p>
</th><th scope="col" valign="top"><p>Mouse and Keyboard Binding</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id90557">Tumbling</a></p>
</td><td valign="top"><p>Inspection 
(default)<br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/tumble_cursor.gif" height="35" width="37"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging with the left mouse button.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id34136">Dollying</a></p>
</td><td valign="top"><p>Inspection</p>
<p><br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/dolly_cursor.gif" height="28" width="34"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging while simultaneously pressing the left 
and middle mouse buttons.<a name="idch13.3Dview2"></a></p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id97362">Panning</a></p>
</td><td valign="top"><p>Inspection<br>
<br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/pan_cursor.gif" height="35" width="35"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging with the middle mouse button.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id82935">Roaming</a></p>
</td><td valign="top"><p>Navigation 
(default)<br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/walk_cursor.gif" height="31" width="45"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging with the left mouse button.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id61562">Tilting</a></p>
</td><td valign="top"><p>Navigation<br>
<br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/tilt_cursor.gif" height="38" width="43"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging while simultaneously pressing the left 
and middle mouse buttons.<a name="idch13.3Dview3"></a></p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id43061">Sidling</a></p>
</td><td valign="top"><p>Navigation<br>
<br>
</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/sidle_cursor.gif" height="33" width="38"></td></tr></table></div>
</p>
</td><td valign="top"><p>Dragging with the middle mouse button.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id88303">Seeking</a></p>
</td><td valign="top"><p>Inspection and 
Navigation</p>
</td><td valign="top"><p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/seek_cursor.gif" height="29" width="34"></td></tr></table></div>
</p>
</td><td valign="top"><p>Clicking with the left mouse button.<sup>[<a name="id5499842" href="#ftn.id5499842">a</a>]</sup></p>
</td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div class="footnote"><p><sup>[<a name="ftn.id5499842" href="#id5499842">a</a>] </sup>Many applications need to reserve clicking with the left mouse button for a more useful function (for example, 
activating a link or initiating object behavior). In those applications, allow users to first activate a seek tool, 
then click in the scene with the left mouse button to seek.</p>
</div></td></tr></tbody></table></div><br><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5499857"></a><a name="id34679"></a>Inspection Functions for 3D Viewing</h3></div></div>
<p>This section first gives an overview of inspection, then describes three viewing functions that apply only to inspection (and not to navigation):</p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch13.html#id90557">&#8220;Tumbling&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id34136">&#8220;Dollying&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id97362">&#8220;Panning&#8221;</a></p>
</li>
</ul></div><p>The section also discusses <a href="ch13.html#id88303">&#8220;Seeking,&#8221;</a> which has the same effect in both inspection and navigation.</p>
<p>Each function is first presented from the user's point of view, then discussed in terms of the implementation model. </p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5499952"></a><a name="id10928"></a>Inspection Overview</h4></div></div>
<p>Inspection is an approach to viewing where users can examine a scene as if it's a single object they are holding in their hand. For example, users may want to examine the model of a coffee mug the same way they would examine a real mug by holding it and turning it around.<a name="idch13.3Dview4"></a></p>
<p>The expected user model for inspection is that users are manipulating the scene, not the camera. From the users' perspective, all inspection controls appear to manipulate the scene (or object) while the camera remains stationary. For example: </p>
<div class="itemizedlist"><ul type="disc"><li><p>Pressing the left mouse button and dragging the pointer down (tumbling) rotates the object towards the user. To achieve this, the application actually moves the camera up over the object (see <a href="ch13.html#id33764">Figure 13-2</a>).</p>
</li>
<li><p>Pressing the middle mouse button and dragging the pointer to the left (panning) moves the scene toward the left of the viewing window. To achieve this, the application moves the camera to the right (see <a href="ch13.html#id75531">Figure 13-5</a>).</p>
</li>
</ul></div><p>Note that in both examples, users move the control (and pointer) in the direction they want the scene (or object) to move. To achieve this, the application moves the camera in the opposite direction of the control (and pointer). </p>
<p><a href="ch13.html#id29484">Table 13-2</a> provides an overview of the different functions available in inspection. </p>
<div class="table"><p><a name="id5500095"></a><b>Table 13-2. <a name="id29484"></a>  Overview of Inspection Viewing Functions</b></p>
<table summary="  Overview of Inspection Viewing Functions" border="1"><colgroup><col><col><col></colgroup><thead><tr valign="top"><th scope="col" valign="top"><p>Function</p>
</th><th scope="col" valign="top"><p>User Model</p>
</th><th scope="col" valign="top"><p>Implementation Model</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id90557">Tumbling</a></p>
</td><td valign="top"><p>User holds object and rotates it to 
view it from all sides and angles.</p>
</td><td valign="top"><p>Camera (eyepoint) moves around a fixed look-at 
point on a spherical course. Camera moves 
opposite to direction of user's action.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id34136">Dollying</a></p>
</td><td valign="top"><p>User moves object closer or farther 
away.</p>
</td><td valign="top"><p>Camera (eyepoint) moves toward a fixed look-at 
point to move object closer and moves away from 
look-at point to move object farther away. 
Viewing direction remains unchanged.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id97362">Panning</a></p>
</td><td valign="top"><p>User moves object up, down, left, 
or right in viewing window. </p>
</td><td valign="top"><p>Camera (eyepoint) moves in plane perpendicular 
to viewing direction. Camera moves opposite to 
movement of object. Viewing direction is 
unchanged. Look-at point moves with camera.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p><a href="ch13.html#id88303">Seeking</a></p>
</td><td valign="top"><p>User selects object (or part of 
object). Selected object is centered 
in viewing window and moved 
closer to user with each click. </p>
</td><td valign="top"><p>Look-at point moves to where user clicked in the 
scene. Camera (eyepoint) turns so that look-at 
point is centered in viewing window. Camera 
moves closer by half the original distance 
between camera and object. </p>
</td></tr></tbody></table></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5500321"></a><a name="id90557"></a>Tumbling</h4></div></div>
<p>Tumbling is the default viewing function for inspection. Users rotate a model of an object or a scene as if they were holding it in their hand. Users expect to be able to tumble the object in all three dimensions around the fixed look-at point. Tumbling doesn't change the location of the object in space.<a name="idch13.3Dview5"></a></p>
<p>The user controls tumbling by dragging with the left mouse button. The movement follows a virtual trackball imposed on the viewing window. The initial position of the pointer on this virtual trackball influences the tumbling behavior: If the user positions the pointer in the center of the viewing window (trackball) and drags horizontally (or vertically), the object tumbles around the y axis (or x axis). If the user positions the pointer in the center of the viewing window and drags out in any direction, the object tumbles around an axis perpendicular to the drag. If the user drags in a circle around the center of the virtual trackball, the object tumbles around the z axis. If the user drags beyond the limits of the trackball, the object continues to tumble until the user releases the mouse button.</p>
<p><a href="ch13.html#id33764">Figure 13-2</a> illustrates tumbling from the implementation perspective. The camera (eyepoint) moves around the scene as though the camera were placed on the surface of a sphere. The look-at point remains stationary at the center of the sphere. The camera moves opposite to the direction of the rotation. Using the original camera position, the user can look into the pot but can't see much of the pot's outside surface. After the user has tumbled the bottom of the pot upwards, it's possible to see the pot's surface. To accomplish this rotation, the eyepoint (camera) moves down along the surface of the sphere and the look-at point remains stationary. <a name="idch13.3Dview6"></a></p>
<p><div class="figure"><p><a name="id5500392"></a><b>Figure 13-2. <a name="id33764"></a>Schematic Illustration of Tumbling (Implementation Perspective)</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/tumbling.gif" alt="Figure 13-2 Schematic Illustration of Tumbling (Implementation Perspective)" height="283" width="471"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5500420"></a><a name="id34136"></a>Dollying</h4></div></div>
<p>Dollying allows users to move a model of an object or a scene closer or farther away. Users move the object as if they were holding it in their hand. The user controls dollying by dragging while simultaneously pressing the left and middle mouse buttons during inspection. Dragging down in the viewing window moves the object closer; dragging up moves it farther away. <a name="idch13.3Dview7"></a></p>
<p><a href="ch13.html#id43472">Figure 13-3</a> illustrates dollying from the implementation perspective. The look-at point and viewing direction are fixed. The camera (eyepoint) moves toward the look-at point along the viewing direction to move the object closer to the user. If the user wants to move the object further away, the camera would move away from the look-at point.</p>
<p><div class="figure"><p><a name="id5500483"></a><b>Figure 13-3. <a name="id43472"></a>Schematic Illustration of Dollying (Implementation Perspective) </b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/dollying.gif" alt="Figure 13-3 Schematic Illustration of Dollying (Implementation Perspective) " height="492" width="462"></td></tr></table></div></div><br>
</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>When users move closer to an object, they eventually reach the point where they would touch the object. As they dolly even farther forward, the eyepoint moves past the (fixed) look-at point as if the user just moved through the object. When the user passes this point, the tumble controls are &#8220;reversed&#8221; because the user is now dragging along the inside of the virtual trackball (see <a href="ch13.html#id90557">&#8220;Tumbling&#8221;</a>) and along its backside. <a name="idch13.3Dview8"></a>
</td></tr></table><hr noshade="noshade"></div><p>Dollying is different from zooming. In both cases the objects change in size in the viewing window. However, in contrast to dollying, zooming doesn't move the object closer or farther away from the user. Zooming instead allows users to change the viewing angle of the camera, the same way they would use a zoom lens on an actual camera. That is, as the user zooms out the viewing angle is increased so that the viewing area becomes larger and more of the scene is visible. This new larger viewing area is then mapped to the viewing window. <a name="idch13.3Dview9"></a></p>
<p>As shown in <a href="ch13.html#id31766">Figure 13-4</a>, objects appear larger (or smaller) after zooming in (or out) even though the location of the camera hasn't changed. This is because the viewing angle changes but the size of the viewing window hasn't changed.</p>
<p><div class="figure"><p><a name="id5500607"></a><b>Figure 13-4. <a name="id31766"></a>Schematic Illustration of Zooming (Implementation Perspective)</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/zooming.gif" alt="Figure 13-4 Schematic Illustration of Zooming (Implementation Perspective)" height="549" width="507"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5500655"></a><a name="id97362"></a>Panning</h4></div></div>
<p>Panning allows users to move a model of an object or a scene up, down, left, or right in the viewing window. Users move the object as if they were holding it in their hand. The user controls panning by dragging while pressing the middle mouse button. The object moves in the direction of the drag; for example, dragging up in the viewing window moves the object up and dragging left moves the object left.<a name="idch13.3Dview10"></a></p>
<p><a href="ch13.html#id75531">Figure 13-5</a> illustrates panning from the implementation perspective. The camera (eyepoint) moves in the plane perpendicular to the viewing direction. The camera moves opposite to the movement of the object. As shown in the figure, the camera moves right, which moves the scene to the left in the viewing window. The look-at point moves with the camera. The viewing direction is unchanged.</p>
<p><div class="figure"><p><a name="id5500700"></a><b>Figure 13-5. <a name="id75531"></a>Schematic Illustration of Panning (User Drags Right)</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/panning.gif" alt="Figure 13-5 Schematic Illustration of Panning (User Drags Right)" height="489" width="481"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5500728"></a><a name="id88303"></a>Seeking</h4></div></div>
<p>Seeking allows users to move an object in the scene into the center of the viewing window. In inspection, the user model is that the user is incrementally moving the object closer (see <a name="idch13.3Dview11"></a><a href="ch13.html#id10928">&#8220;Inspection Overview&#8221;</a>). In navigation, the user model is that the user is incrementally moving closer to the object (see <a href="ch13.html#id83395">&#8220;Navigation Overview&#8221;</a>).</p>
<p> For both inspection and navigation, the user controls seeking by clicking on the object (or part of the object) of interest. Clicking on the object centers the object (or part) in the viewing window and brings the object and user closer together. Each additional click on the same object (or part) brings the object and user still closer. <a href="ch13.html#id47218">Figure 13-6</a> shows a simple example of seeking to the door of a house. The first click on the door positions the door in the center of the viewing window and halves the distance between the door and the user. The second click halves the distance again.</p>
<p>Many applications need to reserve clicking with the left mouse button for a more critical or useful function (for example, activating a link or initiating object behavior). In those applications, allow users to first activate a seek tool, then click with the left mouse button in the scene to actually seek.</p>
<p><div class="figure"><p><a name="id5500826"></a><b>Figure 13-6. <a name="id47218"></a>Simple Example of Seeking to Door</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/seeking.gif" alt="Figure 13-6 Simple Example of Seeking to Door" height="712" width="519"></td></tr></table></div></div><br>
</p>
<p>From the implementation perspective, seeking sets a new look-at point at the location of the user's click and moves the camera so that this new look-at point is at the center of the viewing window. The camera is also moved forward half the original distance between the camera and the object. Note that in the case of inspection, resetting the look-at point by seeking means that the camera tumbles around this new point after the seeking action. </p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5500866"></a><a name="id33502"></a>Navigation Functions for 3D Viewing</h3></div></div>
<p>This section first gives an overview of navigation, then describes three viewing functions that apply only to navigation (and not to inspection):</p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch13.html#id82935">&#8220;Roaming&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id61562">&#8220;Tilting&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id43061">&#8220;Sidling&#8221;</a></p>
</li>
</ul></div><p><a href="ch13.html#id88303">&#8220;Seeking,&#8221;</a> which has the same effect in both inspection and navigation, is discussed in the preceding section.</p>
<p>Each function is first presented from the user's point of view, then discussed in terms of the implementation model. </p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5500961"></a><a name="id83395"></a>Navigation Overview</h4></div></div>
<p>Navigation is useful when users want to move through a world, for example, walk through a 3D model of a museum or an architectural model. In navigation, the user maneuvers through a fixed, immovable world by walking, flying, or another navigation mechanism. <a name="idch13.3Dview12"></a></p>
<p>The expected user model for navigation is that users are manipulating the camera. From the users' perspective, all navigation controls appear to manipulate the camera while the scene remains stationary. For example: </p>
<div class="itemizedlist"><ul type="disc"><li><p>Pressing the left mouse button and dragging the pointer up while roaming moves the user farther forward into the scene. To achieve this, the application also moves the camera farther into the scene (see <a href="ch13.html#id25744">Figure 13-7</a>).</p>
</li>
<li><p>Pressing the middle mouse button and dragging the pointer to the left while sidling sidesteps the user towards the left of the viewing window. To achieve this, the application also moves the camera to the left (see <a href="ch13.html#id47995">Figure 13-9</a>).</p>
</li>
</ul></div><p>Note that in both examples, users move the control (and pointer) in the direction they want the camera to move. </p>
<p><a href="ch13.html#id66993">Table 13-3</a> provides an overview of the different functions available in navigation.</p>
<div class="table"><p><a name="id5501120"></a><b>Table 13-3. <a name="id66993"></a> Overview of Navigation Viewing Functions</b></p>
<table summary=" Overview of Navigation Viewing Functions" border="1"><colgroup><col><col><col></colgroup><thead><tr valign="top"><th scope="col" valign="top"><p>Function</p>
</th><th scope="col" valign="top"><p>User Model</p>
</th><th scope="col" valign="top"><p>Implementation Model</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" valign="top"><p>Roaming</p>
</td><td valign="top"><p>User moves forward or backward 
in the scene. Turning changes 
direction of movement.</p>
</td><td valign="top"><p>Camera (eyepoint) moves forward or backward 
along viewing direction in the same direction as 
the user action. Viewing direction moves in the 
direction that the user turns. Look-at point 
changes as the viewing direction changes.</p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p>Tilting</p>
</td><td valign="top"><p>User looks up or down. </p>
</td><td valign="top"><p>Viewing direction moves in the direction that the 
user looks (up or down). Position of camera 
(eyepoint) remains fixed. Look-at point changes 
as the viewing direction changes. </p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p>Sidling</p>
</td><td valign="top"><p>User sidesteps left or right in the 
scene or &#8220;elevators&#8221; up or down 
in the scene.</p>
</td><td valign="top"><p>Camera (eyepoint) moves in plane perpendicular 
to viewing direction. Camera moves in the same 
direction as user action. Viewing direction 
remains unchanged. Look-at point moves with 
camera. </p>
</td></tr><tr valign="top"><td scope="row" valign="top"><p>Seeking</p>
</td><td valign="top"><p>User selects object (or part of 
object). Selected object is centered 
in viewing window and moved 
closer to user with each click. </p>
</td><td valign="top"><p>Look-at point moves to where user clicked in the 
scene. Camera (eyepoint) turns so that look-at 
point is centered in viewing window. Camera 
moves closer by half the original distance 
between camera and object. </p>
</td></tr></tbody></table></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5501321"></a><a name="id82935"></a>Roaming</h4></div></div>
<p>Roaming (and turning) is the default viewing function for navigation. Users move through a fixed scene as if walking through it. While users are moving they expect to be able to turn to change the direction of the movement. Users control roaming by dragging with the left mouse button while the application is in view mode. Since users may sometimes want to turn without moving, dragging on the horizontal is interpreted differently than dragging in other directions as follows: </p>
<div class="itemizedlist"><ul type="disc"><li><p>Dragging up in the viewing window moves the user forward into the scene; dragging down moves the user backwards out of the scene.</p>
</li>
<li><p>Dragging directly left on the horizontal in the viewing window turns the user left without any forward or backward movement; dragging directly right turns the user right without any movement.</p>
</li>
<li><p>Dragging in any direction above the horizontal both turns the user in that direction and moves the user forward in that direction; dragging in any direction below the horizontal both turns the user and moves the user backward in that direction. </p>
</li>
</ul></div><p>From the implementation perspective, the camera (eyepoint) moves forward or backward along the viewing direction in the same direction as the user's action; that is, as the user moves forward, the camera moves forward (see <a href="ch13.html#id25744">Figure 13-7</a>). The viewing direction moves in the same direction that the user turns; that is, as the user turns left, the viewing direction rotates left. If the user indicates a wish to turn but not move (by dragging the pointer directly left or right on the horizontal), the viewing direction changes appropriately but the camera doesn't move forward or backward. The look-at point changes as the viewing direction changes.</p>
<p><div class="figure"><p><a name="id5501402"></a><b>Figure 13-7. <a name="id25744"></a>Schematic illustration of Roaming (Implementation Perspective)</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/roam.gif" alt="Figure 13-7 Schematic illustration of Roaming (Implementation Perspective)" height="572" width="519"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5501449"></a><a name="id61562"></a>Tilting</h4></div></div>
<p>Tilting allows users to look up and down to see an object higher or lower than their current viewing direction in the scene. Tilting doesn't move the user. To move toward an object in the new view, the user has to use roaming (see <a href="ch13.html#id82935">&#8220;Roaming&#8221;</a>). To control tilting, the user simultaneously presses the left and middle mouse buttons and drags. Dragging up in the viewing window tilts the user's head up to look up in the scene; dragging down allows the user to look down.</p>
<p>From the implementation perspective, tilting changes the viewing direction in the same direction the user's head is tilted (see <a href="ch13.html#id32526">Figure 13-8</a>). As the user looks up, the viewing direction moves up; looking down moves the viewing direction down. The location of the camera (eyepoint) doesn't change. The location of the look-at point changes as the viewing direction changes.</p>
<p><div class="figure"><p><a name="id5501501"></a><b>Figure 13-8. <a name="id32526"></a>Schematic Illustration of Tilting (Implementation Perspective).</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/tilt.gif" alt="Figure 13-8 Schematic Illustration of Tilting (Implementation Perspective)." height="479" width="481"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5501528"></a><a name="id43061"></a>Sidling</h4></div></div>
<p>Sidling allows users to sidestep left and right in the scene or to &#8220;elevator&#8221; up and down in the scene. Sidling moves the user left, right, up and down in the plane perpendicular to the viewing direction; it doesn't move the user forward or back in the scene. The user controls sidling by dragging while pressing the middle mouse button. The user moves in the direction of the drag; for example, the user drags left in the viewing window to sidestep to the left. Dragging up moves the user up as if riding on an elevator.<a name="idch13.3Dview13"></a></p>
<p><a href="ch13.html#id47995">Figure 13-9</a> illustrates sidling from the implementation perspective. The camera (eyepoint) moves in the plane perpendicular to the viewing direction. The camera moves in the same direction that the user wants to move. As the user sidesteps left, the camera moves left. If the user moves up, the camera also moves up. The orientation of the camera remains unchanged. The look-at point moves with the camera.</p>
<p><div class="figure"><p><a name="id5501608"></a><b>Figure 13-9. <a name="id47995"></a>Schematic Illustration of Sidling (User Drags Left)</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/panning.gif" alt="Figure 13-9 Schematic Illustration of Sidling (User Drags Left)" height="489" width="481"></td></tr></table></div></div><br>
</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5501636"></a>Guidelines for 3D Viewing Functions</h3></div></div>
<p><span class="bold"><b>When designing the user interface for a 3D application...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Provide a viewing interface regardless of other capabilities of the application (for example, editing).</p>
</li>
</ul></div><p><span class="bold"><b>When designing the user interface for 3D viewing...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Decide whether your application will support inspection, navigation, or both, then provide the appropriate viewing functions. If your application supports both inspection and navigation, choose one as the primary mode for viewing.</p>
</li>
<li><p>Use standard pointer shapes to indicate the current 3D viewing function.</p>
</li>
</ul></div><p><span class="bold"><b>When designing the user interface for INSPECTION in a 3D application...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Support the user model that users are manipulating a scene as though it were a single object they are holding in their hand (not the user model that users are manipulating a camera). From the user's perspective, all controls appear to manipulate the object or scene while the camera remains stationary. </p>
</li>
<li><p>Support tumbling as the default inspection function to allow users to view all sides of the scene. </p>
</li>
<li><p>Assign tumbling to dragging with the left mouse button.</p>
</li>
<li><p>Display the tumble pointer while the user accesses the tumble function. </p>
</li>
<li><p>Support dollying to allow users to move the scene closer or farther away. </p>
</li>
<li><p>Assign dollying to dragging with the left and middle mouse buttons pressed simultaneously. </p>
</li>
<li><p>Display the dolly pointer while the user accesses the dolly function. </p>
</li>
<li><p>Support panning to allow users to move the scene left, right, up, or down. </p>
</li>
<li><p>Assign panning to dragging with the middle mouse button.</p>
</li>
<li><p>Display the pan pointer while the user accesses the panning function.</p>
</li>
<li><p>Support seeking to allow users to change the look-at point and center the object of interest and to bring the object incrementally closer.</p>
</li>
<li><p>Support seeking as follows:</p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>If your application needs to reserve clicking with the left mouse button for a more critical or useful function, allow users to seek by first activating a seek tool, then clicking with the left mouse button in the scene. Otherwise, support seeking without the use of a tool.</p>
</li>
<li><p>In either case, the user seeks by clicking on a part of the scene with the left mouse button. The application centers that part of the scene in the viewing window and moves the scene closer by half the distance between the camera and the object. </p>
</li>
<li><p>With each subsequent click on the same part of the scene, the scene again moves closer. </p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>Display the seek pointer while the user accesses the seek function.</p>
</li>
</ul></div><p><span class="bold"><b>When designing the user interface for NAVIGATION in a 3D application...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Support the user model that the scene is stationary and the user is moving through this fixed, immovable world. From the user's perspective, all navigation controls appear to manipulate the camera (user's view into the world) while the scene remains stationary. </p>
</li>
<li><p>Support roaming as the default navigation function. In roaming, the user can move forward and backward, turn left and right, and turn while moving. </p>
</li>
<li><p>Assign roaming to dragging with the left mouse button. </p>
</li>
<li><p>Display the roam pointer while the user accesses the roaming function. </p>
</li>
<li><p>Support tilting to allow users to change their view of the scene by tilting their head up and down. Tilting doesn't move the user forward or backward. </p>
</li>
<li><p>Assign tilting to dragging with the left and middle mouse buttons pressed simultaneously. </p>
</li>
<li><p>Display the tilt pointer while the user accesses the tilting function. </p>
</li>
<li><p>Support sidling to allows users to sidestep left and right and to move up and down as if on an elevator.</p>
</li>
<li><p>Assign sidling to dragging with the middle mouse button.</p>
</li>
<li><p>Display the sidle pointer while the user accesses the sidling function, </p>
</li>
<li><p>Support seeking to allow users to move closer to an object in the scene.</p>
</li>
<li><p>Support seeking as follows:</p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>If your application needs to reserve clicking with the left mouse button for a more critical or useful function, allow users to seek by first activating a seek tool, then clicking with the left mouse button in the scene. Otherwise, support seeking without the use of a tool.</p>
</li>
<li><p>In either case, the user seeks by clicking on a part of the scene with the left mouse button. The application centers that part of the scene in the viewing window and moves the scene closer by half the distance between the camera and the object. </p>
</li>
<li><p>With each subsequent click on the same part of the scene, the scene again moves closer. </p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>Display the seek pointer while the user accesses the seek function.</p>
</li>
</ul></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5502016"></a><a name="id94814"></a>3D Viewing Interface Trade-Offs</h2></div></div>
<p>When designing a user interface for viewing in a 3D application, developers often need to address the design issues discussed in this section:<a name="idch13.3Dview14"></a><a name="idch13.3Dview15"></a></p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch13.html#id62811">&#8220;Viewing and Editing in 3D Applications&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id85958">&#8220;Single-Viewport and Multi-Viewport Viewing in 3D Applications&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id30380">&#8220;3D Viewing Performance and Scene Fidelity&#8221;</a></p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5502105"></a><a name="id62811"></a>Viewing and Editing in 3D Applications</h3></div></div>
<p>Only a limited number of mouse and keyboard key combinations is available for interacting with an application. Users therefore can't easily have access to all necessary editing and viewing functions at the same time. Instead, they need to switch contexts between editing and viewing so that they can use the same mouse and keyboard combinations in the different contexts to access different functions.</p>
<p>This context switch is best done by splitting editing and viewing functionality into two separate explicit modes. Using explicit modes avoids a potentially confusing interface that may result if the user doesn't know whether the next action will change the view of the object or the object itself. </p>
<p>In general, when users work with an application that allows editing, they like to be offered several ways to access the viewing functions, and they like to always have quick access to these functions. </p>
<p>The following sections discuss several techniques for providing both viewing and editing capabilities to the user: </p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch13.html#id72813">&#8220;Separate View and Edit Modes&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id23130">&#8220;View Overlay&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id91257">&#8220;Viewing Controls&#8221;</a></p>
</li>
<li><p><a href="ch13.html#id55792">&#8220;Dedicated Viewing Peripheral Devices&#8221;</a></p>
</li>
</ul></div><p>No matter how an application allows users access to viewing and editing, it's important to always display the correct pointer shape to let users know which function they are currently performing. See <a href="ch12.html#id75279">&#8220;Pointer Shapes for 3D Functions&#8221; in Chapter 12</a>.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502270"></a><a name="id72813"></a>Separate View and Edit Modes</h4></div></div>
<p>If an application supports editing, separate and explicit view and edit modes are highly recommended. This allows more flexibility in assigning functions to mouse and keyboard key combinations. In edit mode, mouse and keyboard input perform editing functions on selected objects and on the scene; in view mode, mouse and keyboard input perform viewing functions.<a name="idch13.3Dview16"></a></p>
<p>Users expect an obvious mechanism to switch modes, for example an item in a pull-down menu or a button on a tool palette that provides a variety of possible modes. In addition, users also expect to be able to switch modes using the &lt;Esc&gt; key (see <a name="idch13.3Dview17"></a><a href="ch12.html#id94371">&#8220;Using Modifier Keys in 3D Applications&#8221; in Chapter 12</a>). Pressing this key takes the user to the next mode.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502324"></a><a name="id23130"></a>View Overlay</h4></div></div>
<p>When they are editing, users expect to always have quick access to viewing with a view overlay. A view overlay is a temporary view mode that's available while the user holds down the &lt;Alt&gt; key (see <a name="idch13.3Dview18"></a><a name="idch13.3Dview19"></a><a href="ch12.html#id94371">&#8220;Using Modifier Keys in 3D Applications&#8221; in Chapter 12</a>). As long as the &lt;Alt&gt; key remains pressed, mouse and keyboard input is temporarily interpreted as providing viewing input rather than editing input. Releasing the &lt;Alt&gt; key returns the application to standard editing operations. If the application is already in view mode when the user presses the &lt;Alt&gt; key, the &lt;Alt&gt; key is ignored. </p>
<p>A view overlay offers users quick access to temporary viewing but allows them to stay focused on the editing tasks at hand. This avoids forcing the user to make a heavyweight switch between edit and view modes. Although the view overlay is temporary, users still need to see the correct pointer shape feedback while accessing the viewing functions (for example, the roam pointer or tilt pointer). See <a href="ch12.html#id75279">&#8220;Pointer Shapes for 3D Functions&#8221; in Chapter 12</a>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502412"></a><a name="id91257"></a>Viewing Controls </h4></div></div>
<p>Applications can optionally provide separate user interface controls to access viewing functions. In this approach, all mouse input is interpreted as editing input unless the user is using the mouse pointer to manipulate a viewing control. </p>
<p><a href="ch13.html#id64817">Figure 13-10</a> shows an application window with viewing controls around the sides and the bottom of the window. Manipulating the thumbwheels or sliders with the mouse affects viewing: For example, dragging the thumbwheel in the lower right hand corner of the window dollies the camera, which changes the view but doesn't edit it. Using the mouse in the viewing area of the window performs editing actions: for example, clicking on the star selects that object for editing.<a name="idch13.3Dview20"></a></p>
<p><div class="figure"><p><a name="id5502455"></a><b>Figure 13-10. <a name="id64817"></a>Application With Viewing Controls</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/ch13.3Dview-17.gif" alt="Figure 13-10 Application With Viewing Controls" height="369" width="513"></td></tr></table></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502481"></a><a name="id55792"></a>Dedicated Viewing Peripheral Devices</h4></div></div>
<p>Another optional method of addressing the conflict between viewing and editing input is to assign all viewing actions to one dedicated input device, such as a spaceball. All input from the dedicated input device performs viewing functions; input from other devices performs editing functions. This approach provides more input bandwidth: Context switching between viewing and editing is handled by the choice of input device. <a name="idch13.3Dview21"></a></p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5502528"></a><a name="id85958"></a>Single-Viewport and Multi-Viewport Viewing in 3D Applications</h3></div></div>
<p>When designing a viewing interface, you must decide whether to offer users only one view of the scene (single-viewport) or multiple views simultaneously (multi-viewport). Multiple views may be, for example, one close-up and one distance view or one view from the top and one from each side. This section presents <a name="idch13.3Dview22"></a><a href="ch13.html#id62256">&#8220;Single-Viewport Viewing&#8221;</a> and <a href="ch13.html#id81758">&#8220;Multi-Viewport Viewing,&#8221;</a> discussing their advantages and disadvantages.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502603"></a><a name="id62256"></a>Single-Viewport Viewing</h4></div></div>
<p>In the single-viewport model, only one view of the scene can be projected to the single viewport at any given time, even if there are multiple cameras in the scene. This is a serially multiplexed approach; different views are presented one after another in the same viewport and the user can switch among them.<a name="idch13.3Dview23"></a></p>
<p>By default, the viewport provides a perspective view of the scene. The view updates as the user selects different cameras.</p>
<p>Single-viewport viewing has these advantages:</p>
<div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>Performance</b></span>&#8212;Updating the contents of one view is less computationally expensive than updating two or more views. Application performance deteriorates as the number of views increases, so single-viewport viewing is faster than multi-viewport viewing. </p>
</li>
<li><p><span class="bold"><b>Space</b></span>&#8212;The view doesn't need to share space with other views in the application window. The total viewing area is dedicated to a single view; this allows the largest possible representation of the 3D data. </p>
</li>
<li><p><span class="bold"><b>Simpler user model</b></span>&#8212;Users have to deal only with one view and one window. In contrast, a multi-viewport model requires that users determine the relationship among the different views or decide how changes in one view influence the other views.</p>
</li>
</ul></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5502703"></a><a name="id81758"></a>Multi-Viewport Viewing</h4></div></div>
<p>In the multi-viewport model, two or more views of a scene are simultaneously available. Typically, there are four views: front, top, one side (typically the right), and perspective. <a name="idch13.3Dview24"></a></p>
<p>A view isn't necessarily bound to a particular camera. For each view, the user can choose which camera to use and what each camera views. For example, to view an object from the bottom that's currently visible from the front, the user can either find a camera that displays it from the bottom or tumble or roam to get that view.</p>
<p>Multi-viewport viewing has the advantage that it allows simultaneous views of different representations of data. Users can examine and edit data from different perspectives simultaneously and can edit and examine data across multiple views without having to switch views. This is important for editing complex objects or during scene composition. While performance can be worse with multiple views (because more windows must be updated during viewing operations), experienced users find multiple views useful because they can coordinate operations across multiple viewports to get more accurate feedback on the actions they are performing.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5502770"></a><a name="id30380"></a>3D Viewing Performance and Scene Fidelity</h3></div></div>
<p>Viewing is critical to interacting with 3D environments and applications. The more responsive the application is during viewing, the more realistic and compelling the user's experience.</p>
<p>To achieve realistic user interaction, an application has to maintain at least 8 fps while the user interacts with the view. The frame rate&#8212;number of frames per second (fps)&#8212;is a good gauge of acceptable viewing performance:<a name="idch13.3Dview25"></a></p>
<div class="itemizedlist"><ul type="disc"><li><p>If the frame rate drops below 8 fps, users typically find interacting with the application cumbersome. </p>
</li>
<li><p>In an editing context, 10-12 fps can be sufficient. </p>
</li>
<li><p>15 fps is the minimum frame rate to give the user a fluid, in-control experience. Action games or immersive experiences may require a greater frame rate to achieve that goal. </p>
</li>
</ul></div><p>Some 3D scenes are so complex that just rotating the view becomes computationally expensive. In that case, the 3D scene can't be rendered at an acceptable frame rate. In such situations, applications must provide automatic adaptive rendering, user-controlled adaptive rendering, or both:</p>
<div class="itemizedlist"><ul type="disc"><li><p>In automatic adaptive rendering, the application always maintains viewing responsiveness at the expense of scene fidelity. </p>
</li>
<li><p>In user-controlled adaptive rendering, users explicitly choose between adaptive rendering (that is, maintaining viewing responsiveness at the expense of scene fidelity) and fully rendering the contents of the scene (but taking a performance hit during viewing). This choice is important if users sometimes need fully rendered, high-fidelity scenes and, therefore, need to turn off adaptive rendering. </p>
</li>
</ul></div><div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>It isn't acceptable to let the frame rate drop below 8 fps without explicit user confirmation. 
</td></tr></table><hr noshade="noshade"></div><p>Adaptive rendering maintains viewing performance by changing the rendering characteristics of objects and elements during viewing operations. Typically, some detail is omitted from the display to reduce the computational requirements. As a result, a higher frame rate is achieved at a somewhat lower level of fidelity. Once viewing stops, the scene is returned to its original fidelity. Most users are satisfied with such a trade-off. Without adaptive rendering, users complain of poor performance or sluggishness. Adaptive rendering maintains responsive behavior without reducing functionality or impeding user tasks.<a name="idch13.3Dview26"></a></p>
<p>To implement adaptive rendering, an application can use techniques such as turning off texturing when an object is being moved, or using wireframe models. If an application has multiple views, adaptive rendering can be implemented by updating only one of the views. Then, when the view is no longer changing, the other views can be updated.<a name="idch13.3Dview27"></a></p>
<p>Note that if an application uses only automatic adaptive rendering, it needs to provide users easy access to fully rendered scenes. At a minimum, this should occur when the user stops interacting with the view. </p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5502915"></a><a name="id93079"></a>3D Viewing Trade-Offs and Related Guidelines</h3></div></div>
<p><span class="bold"><b>To make viewing quickly and easily accessible in 3D applications...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Always provide ready access to viewing no matter what the user is doing (for example editing). </p>
</li>
</ul></div><p><span class="bold"><b>When designing a viewing interface for a 3D application that also supports editing...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Display the appropriate pointer depending on the task the user is performing: </p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>While the user is accessing editing functions, display the edit pointer. </p>
</li>
<li><p>While the user is accessing viewing functions, display the appropriate view pointer based on the user's current viewing function (for example, the roaming pointer if the user is currently navigating a scene). </p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>Provide a modal interface to viewing and editing whenever possible. </p>
</li>
<li><p>Provide an obvious mechanism for changing between the view and edit modes, such as buttons in a tool palette or entries in a pull-down menu. </p>
</li>
<li><p>Reserve the &lt;Esc&gt; key for switching between the view and edit modes.</p>
</li>
<li><p>Always provide a view overlay for quick access to viewing. That is, when the primary task is editing, the user can at any time temporarily enter a view mode by pressing and holding the &lt;Alt&gt; key. The user can release the &lt;Alt&gt; key to return the application to edit mode. </p>
</li>
<li><p>Reserve the &lt;Alt&gt; key for providing access to a view overlay. If the user is already in view mode, the &lt;Alt&gt; key has no effect. </p>
</li>
<li><p>Display the appropriate pointer for the current viewing function (for example, the tumble pointer or the roaming pointer) while the user is accessing a view overlay.</p>
</li>
<li><p>Optionally provide additional ways to access viewing, for example, offer viewing fixtures or split viewing and editing input across separate dedicated input devices. </p>
</li>
</ul></div><p><span class="bold"><b>When deciding between a single viewport and multiple viewports...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Use a single viewport if the user doesn't need to do much editing, performance or screen real estate is critical, you need a simple user model, or if several of these conditions are met. </p>
</li>
<li><p>Support multiple viewports if the user needs two or more views of the data simultaneously (such as when editing complex objects or working on scene composition) and performance isn't a critical issue.</p>
</li>
</ul></div><p><span class="bold"><b>When designing a viewing interface for a single viewport...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Use the perspective view of the scene as the default view. </p>
</li>
<li><p>Update the single-viewport view with a new view as the user selects different cameras.</p>
</li>
</ul></div><p><span class="bold"><b>When making viewing performance design decisions...</b></span></p>
<div class="itemizedlist"><ul type="disc"><li><p>Support a minimum frame rate of 8 fps when the user is interacting with the view.</p>
</li>
<li><p>Ideally, support a minimum rate of 10-12 fps for editing and a minimum frame rate of 15 fps for a realistic interactive experience. </p>
</li>
<li><p>If the frame rate drops below 8 fps, provide at least one of the following solutions:</p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>Automatic adaptive rendering, where the application always maintains an acceptable frame rate at the expense of scene fidelity. </p>
</li>
<li><p>User-controlled adaptive rendering, where the user explicitly chooses between adaptive rendering (acceptable frame rate but loss of detail) and fully rendering the contents of the scene (at a possibly unacceptably low frame rate). </p>
</li>
</ul></div><div class="itemizedlist"><ul type="disc"><li><p>If users sometimes need fully rendered, high-fidelity scenes and the frame rate is likely to drop below 8 fps, provide user-controlled adaptive rendering.</p>
</li>
<li><p>If you application only provides automatic adaptive rendering, provide users ready access to fully rendered scenes. At a minimum, this should happen when the user stops interacting with the view. </p>
</li>
</ul></div></div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch12.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch14.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 12. Introduction to 3D Style Guidelines </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 14. Selection in 3D Applications </td></tr></table></div></body></html>
